#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require_relative '../config/application'

class CLI < Thor
  desc "startwallet", "Start wallet as daemon."
  def startwallet
    return if wallet_running?
    `bin/wallet -d`
  end

  desc "stopwallet", "Stop wallet daemon."
  def stopwallet
    `cat #{"#{__dir__}/../tmp/walletd.pid"} | xargs kill`
  end

  desc "statuswallet", "Show wallet status."
  def statuswallet
    pid = wallet_running?

    print "Status: "
    if pid
      say "Running", [:green, :bold]
      say "PID: #{pid}" if pid
    else
      say "Stopped", [:red, :bold]
    end
  end

  desc "getbalance <color_id>", "Get current balance. If color_id specified show balance of token."
  def getbalance(color_id = nil)
    color_id = 'TPC' if color_id.nil?
    balance = Utxo.where(token: color_id).sum(:value)

    say balance.to_s.reverse.gsub( /(\d{3})(?=\d)/, '\1,').reverse
  end

  desc "listunspent", "Show UTXO list"
  def listunspent
    pp Utxo.all.map(&:attributes)
  end

  desc "dumpprivkey", "Dump private key."
  def dumpprivkey
    key = nil
    File.open("credentials/jwk.json") do |f|
      jwk_hash = JSON.load(f)
      jwk = JSON::JWK.new(jwk_hash)
      key = Tapyrus::Key.new(priv_key: jwk.to_key.private_key.to_s(16).downcase.encode('US-ASCII'), key_type: 0)
    end

    say key.priv_key
  end

  desc "dumppubkey", "Dump public key."
  def dumppubkey
    key = nil
    File.open("credentials/jwk.json") do |f|
      jwk_hash = JSON.load(f)
      jwk = JSON::JWK.new(jwk_hash)
      key = Tapyrus::Key.new(priv_key: jwk.to_key.private_key.to_s(16).downcase.encode('US-ASCII'), key_type: 0)
    end

    say key.pubkey
  end

  desc "createdid", "Create DID."
  def createdid
    if File.exist?("#{__dir__}/../config/credentials/did")
      say "DID is already set."
      exit(1)
    end

    did = Did.generate

    File.open("#{__dir__}/../config/credentials/did", 'w') { |f| f << did.long }
    File.open("#{__dir__}/../config/credentials/jwk.json", 'w') { |f| f << did.jwk.to_json }

    say did.long
  end

  desc "showdid", "Show DID stored in the wallet."
  def showdid
    unless File.exist?("#{__dir__}/../config/credentials/did")
      say "DID does not exist."
      exit(1)
    end

    long = File.open("#{__dir__}/../config/credentials/did", 'r') { |f| f.read }

    say long
  end

  desc "removedid", "Remove DID from the wallet."
  def removedid
    unless File.exist?("#{__dir__}/../config/credentials/did")
      say "DID does not exist."
      exit(1)
    end

    long = File.open("#{__dir__}/../config/credentials/did", 'r') { |f| f.read }
    did = Did.new(long:)

    say "Found: #{did.long}"
    text = "Do you really delete the DID information from the wallet?\nThe DID is never actually deleted, but the private key information on this wallet is lost. (y/N)"

    if yes? text
      File.delete("#{__dir__}/../config/credentials/did")
      File.delete("#{__dir__}/../config/credentials/jwk.json")

      say "config/credentials/did and config/credentials/jwk.json removed."
    else
      say "Canceled."
      exit(1)
    end
  end

  private

  # @return pid|nil
  def wallet_running?
    pid = File.open("#{__dir__}/../tmp/walletd.pid", 'r') { |f| f.read }
    return pid if Process.kill(0, pid.to_i)
  rescue
    nil
  end
end

CLI.start(ARGV)
